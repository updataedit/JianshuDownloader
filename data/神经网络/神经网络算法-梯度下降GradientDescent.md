[神经网络文章索引](https://www.jianshu.com/p/7fb9edd69a3d)

上一篇神经网络结构中，我们介绍了神经元的结构，激活函数以及每个神经元激活值的算法，涉及到权重、偏置值等。

---
##神经网络中的待定值

上一篇结尾提到，对于28*28的黑白手写图像识别，我们需要13002个权重和偏置数值，才能让我们的神经网络最后输出正确结果。

![神经网络结构示意](imgs/4324074-a2a2b8fdef4aca87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![神经网络层激活值算法](imgs/4324074-2faf1277730a75af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![待定的数值](imgs/4324074-23c105af02c4cf14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

所谓的机器学习，就是寻找这13002个数值的过程。首先这里有两点需要注意：
* 这些数值应该能够适应足够多的图片情况，至少能够适应我们已有的几万张手写图片，能够输出正确的结果，而且还应该适应新的未知手写图片，也能预测出正确结果。
* 这些数值未必能应对每种情况，偶尔有几张识别错误应该是可接受的，毕竟人类也做不到全部正确。我们只是希望尽可能多的正确，也就是正确率最高就好。

---
##暴力出奇迹

在负无穷到正无穷之间，如何获得一万多个数字最佳的匹配值？这比在全世界挑选1万人让TA们一起相爱还要难。

我们的做法是用计算机强大运算速度，暴力解决问题。
* 先随机挑选13002个数字作为权重或偏置，放到神经网络里面，假设这就是我们期望的待定值。
* 使用我们已有的几万张手写图片，逐个放到神经网络试验一下，看看它输出的预测结果是否跟我们希望的正确答案相符。
* 开始当然是绝大多数图片预测的结果都和实际数字不相符，甚至没有一张是相符的，因为再多的运气也不够用。
* 虽然不相符，但也许我们能从差距中找到一点规律，猜测哪些数字变大或者变小一点，可能效果会好那么一点，也许会让数万张图片中有那么几张的预测结果是和实际相符的。
* 即使我们只是进步那么一丢丢，那么我们依赖于计算机每秒千亿次的计算能力，不停的实验新的数字，**不停的根据规律优化这些数字**，我们相信，可能数亿次或者数万亿次之后，我们就可以得到比较靠谱的13002个数字的最佳值了。

![用来测试的图片，已经标记正确数字](imgs/4324074-62b82532b097bd0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

好了，现在，暴力不是问题，要想出奇迹的关键就在于如何找到如何**优化的规律**。

---
##代价函数Cost function

要想做优化，首先要明确目标，找到当前神经网络和期望结果之间的差距。

从下图可以看到，随机设定的神经网络最终输出的是混乱的一层（被黄色线框标出），距离最右边我们期望只点亮神经元3的情况差距很大。

![代价是预测结果和实际期望结果之间的差距](imgs/4324074-d83a7a25518ab702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们把混乱输出层的每个神经元与期望层每个对应神经元激活值相减，然后平方，再累加在一起，这就是方差cost代价，如下图，计算得到cost是3.37。

![cost算法](imgs/4324074-2ec7243100c5f601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们用这个cost来表示当前神经网络13002个设定值和期望设定值之间的差距，当然，这个cost等于0是差距最小，也就是最接近期望设定值。——当然这只是针对数字3的1张图片来说，我们需要的是针对0~9共10个数字的数万张图片，cost都能是最小。

---
##最低值

从下图，我们来看一下神经网络的功能。它能利用13002个设定值经过3层神经元激活值的计算，把784个像素亮度变为10个数字（我们期望这10个数字中只有一个是1，其他都是0）。

![神经网络函数](imgs/4324074-b9e643ba79ea3e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这13002个权重和偏置数字，加上激活值的算法，就是神经网络的“想法”。

我们再来看看代价函数的情况，如下图，它是利用很多很多的训练图片（已经明确了对应的数字），把13002个数字变为1个cost代价数。

![代价函数](imgs/4324074-cc229bed51dc3eae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

写成函数形式
![价值函数](imgs/4324074-ee0cd2241f5d4f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


我们假设最简单的情况，只有1个权重和1个偏置：
![价值函数极简化](imgs/4324074-18631e0132d5a603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

x和y是任意可能的数值，我们希望知道当x和y是什么数值的时候z最小。

每一组[x,y]都对应唯一的z，我们可以假想，有无数个[x,y,z]这样的位置点，在三维空间坐标中，它们就会组成一个面（曲面或平面），如下图。

![待定值x,y和代价值z构成的空间曲面](imgs/4324074-8c215ffc88344f48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从几何意义上看，我们就是要找到凹陷最低的那个位置点的x,y的值，因为那里z也就是cost代价最低。

>虽然这里只讨论了xy两个待定值的情况，但实际上它也适用于13002个待定值或者更多待定值的情况。这里是3维空间，那么我们可能需要13003维空间上画这个曲面图，当然这是无法想象的几何造型。

---
##梯度下降Gradient descent

假设上面的xyz绘制的cost曲面是个山地，你是一个旅行者，需要行走找到最低点的位置，你会怎么办？

没错，只要一直往下走，那么就能走到所在区域的最低点。——当然，如果山后面还有更深的山谷，那么你可能找到的只是局部最低点，而并非世界最低点。

实际上，对于复杂的超多维度来说，找到世界最低点几乎是不可能任务。我们唯一能做的就是多找几个局部最低点，然后选择其中最低的那个。

同样，如果我们落脚在[x',y']，那么可以尝试对比[x'+0.1，y']，[x'-0.1，y'],[x'，y'-0.1],[x'，y'+0.1],如果[x'+0.1,y']是最低的，那么我们就走到这里，然后继续尝试对比四周点的高度。这就是梯度下降的算法。

如下图，我们沿着虚线一步一步下山找到最低点。
![梯度下降](imgs/4324074-6fb89a5137879ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>实际上的神经网络使用的算法会复杂不少，利用微分求斜率和梯度，然后逐渐逼近最低点。毕竟我们这种粗糙的算法来说，步子小了速度太慢效率太低，步子大了又可能跨过最低点。

---
##微积分算法

首先快速的从下图了解几个基本概念。
下图的弧线表示的是某个函数y=f(x)，比如抛物线方程y=x<sup>2</sup>。
曲线上任取两个点a,b，它们对应x和x+dx。（d是指德尔塔大写Δ，小写δ）
ab两点对应的y的差是dy。
现在直线ab看上去是曲线的割线（有ab两个交点）。
假设b点沿着曲线，越来越靠近a点，那么dx极限趋近于0，这时候dy也会越来越小趋近于0，但是！我们会意识到dy/dx永远不会是0，而最终它仍然是角∠cab的对边比邻边，也就是正切三角函数值。
实际上，这也正是曲线的切线的定义。
可以想象，我们取的a点越是靠右，那么这个切线越是竖直。
如果我们把这个切线看做表示某个一次方程，如y=mx+n这种形式，那么a点越靠右，直线越竖直，m值也就越大。
我们把m值叫做直线的斜率。
![导数与微分](imgs/4324074-fa05a7a441f86c2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**导数derivative**，一元函数y=f(x)（即因变量y只受到一个自变量x影响的函数）中任意取x，如果x增加极小趋近于0的Δx（或者写为dx),那么y相应的被增加Δy（或者写作dy），那么导数就是dy/dx，而又有dy=f(x+dx)-f(x)，所以：
![导数定义](imgs/4324074-fe7b22d9718a64d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从函数的曲线图上可以看到，某点的导数就是dx趋近于0时候∠cab的正切，导数反映了切线的陡峭程度，也就是y随着x变化的快慢程度。

>注意，导数函数的图形并不是一条直线，因为从图上就可以发现这个斜率f '(x)不是固定的，随着x的增大，f '(x)也会增大（曲线越来越陡峭），所以如果把f '(x)画出来，在这个示例中，它的形状和现有的f(x)曲线差不多，但略低，至少要穿过0点，因为看上去f(x)在x等于0的时候切线接近水平斜率也接近0。所以，**图上直线只反映了a点导数，而不是反映整个导数函数**。

**微分differential**，简单说就是Δx和Δy，或者记作dx和dy。x称之为自变量，y称之为因变量，那么x趋近于最小的时候的值，就是x的微分（趋近0又不是0的那个神秘值），同样y的微分也是这个意思，总之是想得到又摸不到的神奇值。

**斜率slope**，一元一次函数（直线方程）y=mx+n的系数m值。在这里就是a点的导数值f'(x)。

**切线tangent**，某个点a的切线，就是经过a点的，以A点斜率为系数的方程y=f'(x)x+n所表示的直线。

**自变量dependent variable和因变量 independent variable**，x自己的变化，引发y被动变化。

好了，我们来看**多变量微分Multivariable differential**。

上面都是一个y收到一个x的影响y=f(x)，多变量就是不止受到一个自变量的影响，我们以最简单的z=f(x,y)为例，z=x<sup>2</sup>+y<sup>2</sup>。
![多变量微分](imgs/4324074-65319eb8991f8165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

绿轴x的变化和红轴y的变化，都会对应蓝轴z的变化。
x从负无穷到正无穷无限种可能，y也是无限种可能，x和y复合到一起就在水平方向覆盖了全部地面，z值有高有低，就像现实世界中的海拔一样，把xy平面凸起或凹陷。（图中粉色没有画出全部曲面）

我们可以想象，这时候不能讨论A点的切线了，而应该考虑它的**切平面tangent plane**（下图绿色平面）。

**方向导数directional derivative**，就是曲面上过A点的任意曲线的切线（下图紫色线）组成的平面，就是切平面。

![圆点A上的切平面](imgs/4324074-7c5dd34ff25e8c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这么多紫色的方向中，哪一个方向最陡峭？对于这个z=x<sup>2</sup>+y<sup>2</sup>函数来说，明显是最接近竖直朝上的那个箭头和最接近竖直朝下的那个箭头。
和曲线一样道理，越陡峭意味着z对x、y的变化越敏感，或者说dx、dy的变化会引发更多的dz。
**梯度gradient**，我们规定，能够引发因变量最快变化的那个切线正方向，就叫做曲面方程上这个点的梯度。注意梯度是个xyz表示的三维方向，例如[0，0，1]表示z轴竖直向上，[0.1,0.1,1]就往xy的正方向偏一点点。

>还有一个**偏导数partial derivative**是指函数结果相对于其中一个变量的导数，就是多变量中锁定其他变量，只留住一个变量，比如把x锁定为5即x=5时候只留下y和z的变化，这时候变成了z=f(5,y)，其实x这个自变量已经没啥意思了，我们又回到了上面的一元曲线情况，其实这只是三维空间在x=5这个竖直平面上形成的一条二维抛物曲线。同样如果我们锁定不同的z，那么就得到曲面上一圈一圈的地形等高线。把三维转为二维，这就是科幻小说中所说的**降维**攻击。


---
##用微分思考梯度下降

对于只有xy两个变量的三维曲面来说，我们还可以只是考虑x+0.1,x-0.1,y+0.1,y-0.1这样的试探方法找到最低点，只要2*2=4次就可以了，周全一点也就8次。

但是对于我们手写数字识别中13002个自变量来说，那就要2<sup>13002</sup>次，这是不可行的。

借用多元微分，我们可以找到13002个自变量某一随机点对应的切平面（实际早已不是什么平面了，我们姑且这么说），也可以计算出其中变化最快的方向，就是梯度，数学家已经证明，不管多少个维度，沿着梯度往前走一步，都能获得最快变化后新的一个点，这个点是一个n维向量，对于我们的案例来说就是13003个新数字组成的数组[0.322,0.123,0.55,0.222,...0.233]共13003个数字。

![多维函数的负梯度](imgs/4324074-34504d428b4e5954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>表示梯度的倒三角符号读音['næblə] 

唯一要说明的一点不同就是，为了找最低点，我们不是往上走，而是往相反的负方向，朝下走。

**步长step size**，就是我们每次沿着**负梯度**往下走多远，在机器学习算法里面它叫做**学习率learning rate**，同样道理，步子迈小了走得太慢，找到最低点耗时间太久，步子太大了容易跳过最低点（注意，1万多维的复杂情况不是我们上面三维漏斗曲面那么简单可以描述的）。所以我们经常设置0.00001这样小的数字，好在很多机器学习程序都会适当的自动调整它（比如Tensorflow中的梯度下降优化GradientDescentOptimizer），实际上不会让它太慢。

同时，我们从上图中看到，计算出的负梯度是由很多数字组成的数组，每个数字代表一个维度（就像xy那样），所以我们只要在原来的位置点坐标（比如[x,y]）上分别把这个梯度（比如[0.1,-0.3])加上去就能得到新的点([x+0.1,y-0.3])。

>当然这里步长已经考虑在梯度内了，如果没有包含在梯度内，那么应该再乘以步长，假设步长0.01，那么就是[(x+0.1)*0.01,(y-0.3)*0.01]。

---
内容小结

* 神经网络的机器学习就是寻找数以万亿计的待定值的最佳匹配方案
* 就是寻找多维空间中的最低点
* 方法就是逐渐下坡试探寻找
* 算法就是利用微分梯度，逐步下降

>这里最终并没有给出这个梯度的计算公式，实际上我们学习机器学习也并不必要深入到具体运算，了解各个参数名称的概念原理即可。


---
###让知识变得简单
如果您发现文章错误，请不吝留言指正；
如果您觉得有用，请点喜欢；
如果您觉得很有用，感谢转发~
---
END